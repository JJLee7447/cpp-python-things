## 智能指针
1. 什么是智能指针

C++的智能指针其实就是对普通指针的封装（即封装成一个类），通过重载 * 和 ->两个运算符，使得智能指针表现的就像普通指针一样。

2. 智能指针的作用

C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。

3. 智能指针实现原理

智能指针(smart pointer)的通用实现技术是使用引用计数(reference count)。智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象的指针指向同一对象。每次创建类的新对象时，初始化指针就将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，析构函数减少引用计数（如果引用计数减至0，则删除基础对象）。

* share_ptr
* unique_ptr unique_ptr是独享被管理对象指针所有权(owership)的智能指针。unique_ptr对象封装一个原始指针，并负责其生命周期。当该对象被销毁时，会在其析构函数中删除关联的原始指针。
* weak_ptr

### share_ptr 
1. 初始化share_ptr

```c++
//第一种方式 直接调用对象的构造函数
std::shared_ptr<int> p1(new int(1));

//第二种方式，先声明对象然后调用reset初始化
std::shared_ptr<int>p2;
p2.reset(new int(1));

//第三种方式 也是推荐的方式以及最高效的方式 使用make_shared
auto ptr = make_shared<int>(100); //auto 也是C++ 11 的新特性 
//这种初始化方式等价与 std::share<int>ptr(new int(100));
```
 * 这里分析下为什么使用make_shared的创建方式会更加的高效了，在我们是使用 方式1的去初始化一个shared_ptr的时候，我们需要先在堆上申请分配一块内存，用来存储数字1，然后用这个变量调用share_ptr的构造函数，再次分配一次内存，而使用make_shared就只需要分配一次内存就可以了
 * 关于智能指针调用reset的初始化方式，这个函数在智能指针没有值的时候调用是用来初始化的，当这个智能指针有值的时候，调用reset函数就会引起智能指针引用计数-1

2. share_ptr 的一些操作成员函数

```c++
std::share_ptr<int> p1;
p1.reset(new int(10)); //p1未指向任何地址，reset初始化

std::share_ptr<int> p2;
p2 = p1; //p2 与p1 都指向同一块内存地址 引用计数+1
cout << p2.use_count <<endl; // 2  当前有两个share_ptr 强引用这块地址
p1.reset(); //引用计数-1
cout << p2.use_count <<endl;//  获取当前的引用计数的数量 代码见上面

