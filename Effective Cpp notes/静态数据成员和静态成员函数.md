### 一、静态数据成员

**1.静态数据成员怎么去定义？**

在类中声明静态数据成员很简单，是以static关键字表明即可

```cpp
class Test{
private:
	//静态数据成员
	static int a;
};
```

要对静态数据成员定义和初始化必须在类的外面也就是在全局作用域中定义，如果定义不给出初值，则默认初值为0

```cpp
class Test{
public:
	int GetA() const{return a;}
private:
	//静态数据成员
	static int a;
};
//int Test::a;如果这样定义不赋予初值则初值为零
int Test::a = 1;
#include <iostream>
int main()
{
	Test T;
	std::cout << T.GetA() << std::endl;
}
```

​		静态数据成员甚至在类没有任何对象的时候都可以访问，静态成员可以独立访问，无需依赖任何对象的建立。另外，==不要试图在头文件中定义(初始化)静态数据成员==。在大多数的情况下，这样做会引起重复定义这样的错误。即使加上`#ifndef #define #endif`或者`#pragma once`也不行。

**2.静态数据成员被类的所有对象共享，包括该类的派生类对象，基类对象和派生类对象共享基类的静态数据成员**

​		静态数据成员不属于任何对象，类的静态数据成员的存在不依赖于任何类对象的存在，静态数据成员是由类的所有对象共享的。

```cpp
class Base{
public:
	//静态数据成员
	static int a;
};
class Derived : public Base{
 
};
//int Test::a;如果这样定义不赋予初值则初值为零
int Base::a;
#include <iostream>
int main()
{
	Base B;
	Derived D;
	B.a++;
	std::cout << B.a << std::endl;
	D.a++;
	std::cout << D.a << std::endl;
	
}
/*
 *1
 *2
*/
```

​		由打印结果看出来，派生类对象和基类对象都是共享基类的静态数据成员，而基类的所有对象也是共享该静态数据成员，且该静态数据成员应该在全局作用域中定义，可以赋予初值也可以不赋予初值，如果不赋予初值，静态数据成员有其默认值。

**3.静态数据成员可以作为成员函数的默认形参，而普通数据成员则不可以**

```cpp
class Test{
public:
	//静态数据成员
	static int a;
	int b;
	void fun_1(int i = a);//正确
	void fun_2(int i = b);//报错
};
```

**4.静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以。普通数据成员的只能声明为 所属类类型的 指针或引用**

```cpp
class Test{
public:
	Test():b(0){}
	//静态数据成员
	static int a;//正确
	int b;
	void test() const
	{
		a++;
		b++;//const指的不能修改当前调用该函数对象的数据成员
	}
};
int Test::a;
```

​		`const`修饰的时当前`this`指针所指向的对象是`const`，但是静态数据成员不属于任何类的对象，它被类的所有对象修改，所以`this`指针不修饰静态的数据成员，所以可以更改。

### 二、静态成员函数

静态成员函数的声明也很简单，就是在类的成员函数前加上static关键字即可，和静态成员一样，静态成员函数也是属于类的，它并不属于任何对象，当调用静态成员函数时应该使用类名和域运算符“∷”，当然也可以使用对象调用操作，但是这样的操作并不意味着静态成员函数属于这个对象，它只是被这个对象共享而已，这样也就决定了静态成员函数中是不能访问本类中的非静态数据成员的，它是不能访问非静态数据成员的，在c++中静态成员函数主要用来访问静态数据成员而不访问非静态数据成员

**1.静态成员函数不能调用非静态成员函数，但是反过来是可以的**

**2.静态成员函数没有this指针，也就是说静态成员函数不能使用修饰符(也就是函数后面的const关键字)**

**3.静态成员函数的地址可用普通函数指针储存，而普通成员函数地址需要用 类成员函数指针来储存。**

总结：其实声明为静态，不论是静态数据成员还是静态成员函数，它们都是不依赖于对象而存在的，类在定义后并不分配存储空间，而是在定义类的对象的时候才分配存储空间，相反静态的数据成员和静态的成员函数是已经在内存中开辟了内存空间了，所以静态数据成员可以独立的访问在任何类对象没有建立起来都可以访问，并且静态成员函数不可以调用非静态成员函数，因为非静态成员函数只有在类对象建立以后才可以调用，相反则是可以的。我觉得当对某个判断产生怀疑的时候应该去测试，只有验证了才知道是不是对的哈！

为了能更好阐释静态数据成员和静态成员函数，然后在网上搜了博客，感觉有些例子不错(因找不到最初的出处，所以无法注明请原作者谅解)，所以就拿来给大家参考一下哈！

关于玩篮球的例子很能明显解释静态数据成员和静态成员函数到底是怎么回事

你们班里面有10个人（10个比如高一一班的对象），体育老师分给你们一个篮球（静态成员函数），你们每个人都带了一个篮球（非静态成员数），你们都很小气，自己的球只能自己拍，要是5对5打比赛，那就只能用那个静态的篮球了（每个人都可以拿来用，但是带来的影响是对全体的）。因此，我可以说那个篮球是高一一班的成员。所以也就是说：静态成员函数是类的成员函数（因为高一二班就不能拿来玩），但是这个篮球最后还是要还给老师的，任何私人不得占有。希望这样你能明白，其实在内存空间里面说白了静态的成员的内存是唯一的一份，就是当你在类外声明他时开辟的，但是非静态函数的空间分配是在你实例化对象时创建的。

```cpp
//定义Student类
#include <iostream>
class Student                  
{
public:
//定义构造函数
Student(int n,int a,float s):num(n),age(a),score(s){ }      
void total();
//声明静态成员函数
static float average();      
private:
	int num;
	int age;
	float score;
	//静态数据成员，累计学生的总分
	static float sum; 
	//静态数据成员，累计学生的人数
	static int count;           
};
//在全局作用域对静态数据成员初始化，如果不赋予初值，则使用其默认值零
float Student::sum;                     
int Student::count;
//定义非静态成员函数
void Student::total()                    
{
	//累加总分
	sum+=score;
	//累计已统计的人数
	count++;                               
}
//定义静态成员函数
float  Student::average()                  
{
	return(sum/count);
}
int main()
{
	Student stud[3]={    
	//定义对象数组并初始化
	Student(1001,18,70),
	Student(1002,19,78),
	Student(1005,20,98)
};
int n;
std::cout<<"please input the number of students: ";
 //输入需要求前面多少名学生的平均成绩
std::cin>>n;                              
//调用3次total函数
for(int i=0;i<n;i++)
{
	stud[i].total();
}
//调用静态成员函数
std::cout<<"the average score of "<<n<<" students is "<<Student::average( )<<std::endl;
return 0;
}
/*
 *please input the number of students: 3
 *the average score of 3 students is 82
*/
```

首先，在主函数中定义了对象数组，存放每个学生的编号、年龄和成绩，其中`sum`和`count`是要累计所有学生的总成绩和总的学生人数，我们定义成了静态数据成员，在学生类的成员函数中，我们定义了普通的total成员函数，用来计算所有学生的总成绩和总的学生人数，另外，定义了静态成员函数average，学生类的设计大概如此

在全局作用域对类中静态数据成员进行了定义，但未赋予初值，这意味着我们采用其默认值。

在类的普通成员函数toal中可以引用静态数据成员`sum`和`count`，可见类的所有成员函数都可以引用类的静态数据成员。

在类的静态成员函数`average`中，只能引用类的静态数据成员，不能引用非静态数据成员。

在主函数中我们调用类的非静态成员函数时只能通过类对象来调用，如`stu[i].total`，但是对于静态成员函数可以直接通过类名+作用域符号来调用，如

`Student::average`
