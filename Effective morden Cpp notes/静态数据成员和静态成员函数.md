### 一、静态数据成员

**1.静态数据成员怎么去定义？**

在类中声明静态数据成员很简单，是以static关键字表明即可

```cpp
class Test{
private:
	//静态数据成员
	static int a;
};
```

要对静态数据成员定义和初始化必须在类的外面也就是在全局作用域中定义，如果定义不给出初值，则默认初值为0

```cpp
class Test{
public:
	int GetA() const{return a;}
private:
	//静态数据成员
	static int a;
};
//int Test::a;如果这样定义不赋予初值则初值为零
int Test::a = 1;
#include <iostream>
int main()
{
	Test T;
	std::cout << T.GetA() << std::endl;
}
```

​		静态数据成员甚至在类没有任何对象的时候都可以访问，静态成员可以独立访问，无需依赖任何对象的建立。另外，==不要试图在头文件中定义(初始化)静态数据成员==。在大多数的情况下，这样做会引起重复定义这样的错误。即使加上`#ifndef #define #endif`或者`#pragma once`也不行。

**2.静态数据成员被类的所有对象共享，包括该类的派生类对象，基类对象和派生类对象共享基类的静态数据成员**

​		静态数据成员不属于任何对象，类的静态数据成员的存在不依赖于任何类对象的存在，静态数据成员是由类的所有对象共享的。

```cpp
class Base{
public:
	//静态数据成员
	static int a;
};
class Derived : public Base{
 
};
//int Test::a;如果这样定义不赋予初值则初值为零
int Base::a;
#include <iostream>
int main()
{
	Base B;
	Derived D;
	B.a++;
	std::cout << B.a << std::endl;
	D.a++;
	std::cout << D.a << std::endl;
	
}
/*
 *1
 *2
*/
```

​		由打印结果看出来，派生类对象和基类对象都是共享基类的静态数据成员，而基类的所有对象也是共享该静态数据成员，且该静态数据成员应该在全局作用域中定义，可以赋予初值也可以不赋予初值，如果不赋予初值，静态数据成员有其默认值。

**3.静态数据成员可以作为成员函数的默认形参，而普通数据成员则不可以**

```cpp
class Test{
public:
	//静态数据成员
	static int a;
	int b;
	void fun_1(int i = a);//正确
	void fun_2(int i = b);//报错
};
```

**4.静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以。普通数据成员的只能声明为 所属类类型的 指针或引用**

```cpp
class Test{
public:
	Test():b(0){}
	//静态数据成员
	static int a;//正确
	int b;
	void test() const
	{
		a++;
		b++;//const指的不能修改当前调用该函数对象的数据成员
	}
};
int Test::a;
```

​		`const`修饰的时当前`this`指针所指向的对象是`const`，但是静态数据成员不属于任何类的对象，它被类的所有对象修改，所以`this`指针不修饰静态的数据成员，所以可以更改。

### 二、静态成员函数